import pandas as pd
import streamlit as st

from .state import AppState


KPI_DESCRIPTIONS = {
    "PV generation": (
        "Total electricity generated by all prosumers' PV systems over the simulated period."
    ),
    "Prosumer demand": (
        "Electricity consumed by prosumers to serve their own load across the community."
    ),
    "HH demand": (
        "Aggregated annual electricity demand of all participating households."
    ),
    "Shop demand": (
        "Aggregated annual electricity demand of all participating shops."
    ),
    "Matched to HH": (
        "Energy from prosumers that has been shared directly with households within the community."
    ),
    "Matched to SHOP": (
        "Energy from prosumers that has been shared directly with shops within the community."
    ),
    "Exports": (
        "Community surplus energy exported to the grid after matching prosumers with consumers."
    ),
    "Imports HH": (
        "Electricity that households still need to import from the grid after matching."
    ),
    "Imports SHOP": (
        "Electricity that shops still need to import from the grid after matching."
    ),
    "Community demand": (
        "Total electricity demand of households and shops combined."
    ),
    "Coverage — total": (
        "Share of the community demand covered by matched prosumer energy (households + shops)."
    ),
    "Coverage — HH": (
        "Share of household demand covered by energy matched from prosumers."
    ),
    "Coverage — SHOP": (
        "Share of shop demand covered by energy matched from prosumers."
    ),
    "PV utilization": (
        "Share of generated PV energy that is consumed within the community "
        "(matched to prosumers, households, or shops)."
    ),
    "Export ratio": (
        "Share of generated PV energy that is exported to the grid after matching and self-consumption."
    ),
    "Autarky — total": (
        "Share of community demand that is served without importing from the grid."
    ),
    "Autarky — HH": (
        "Share of household demand that is served without importing from the grid."
    ),
    "Autarky — SHOP": (
        "Share of shop demand that is served without importing from the grid."
    ),
    "Prosumer uplift rate": (
        "Actual prosumer revenue divided by the revenue they would earn if all surplus were "
        "sold at zonal price plus uplift (no sharing)."
    ),
    "Consumer savings": (
        "Difference between the baseline retail bill and the community bill for all consumers; "
        "displayed in both € and %."
    ),
    "Prosumer revenue": (
        "Total annual revenue earned by prosumers, including self-consumption, matched energy, "
        "and exports minus import costs."
    ),
    "Prosumer revenue from matched energy": (
        "Revenue paid to prosumers for energy matched with households and shops."
    ),
    "Prosumer revenue from export": (
        "Revenue from selling surplus energy to the grid at zonal price plus uplift."
    ),
    "Consumer baseline": (
        "Total amount consumers would pay under baseline retail tariffs without joining the community."
    ),
    "Consumer baseline HH": (
        "Baseline retail expenditure for all households without the community."
    ),
    "Consumer baseline SHOP": (
        "Baseline retail expenditure for all shops without the community."
    ),
    "Consumer cost — total": (
        "Actual amount paid by all consumers after participating in the community."
    ),
    "Consumer savings — HH": (
        "Household baseline bill minus the actual household bill within the community."
    ),
    "Consumer savings — SHOP": (
        "Shop baseline bill minus the actual shop bill within the community."
    ),
    "Platform gap revenue": (
        "Revenue retained by the platform from spread/gap mechanisms applied to matched energy."
    ),
    "Platform fees": (
        "Annual platform membership fees collected from prosumers, households, and shops."
    ),
    "Platform fixed cost": (
        "Annual fixed operating cost borne by the platform."
    ),
    "Platform margin": (
        "Platform gap revenue plus fees minus fixed costs (i.e. annual platform profit)."
    ),
}

def _safe_ratio(num: float, den: float) -> float:
    if den <= 0:
        return 0.0
    return float(num) / float(den)


def compute_kpi_summary(S: AppState) -> pd.DataFrame:
    if S.result is None:
        return pd.DataFrame(columns=["KPI", "unit", "value", "description"])

    totals = S.result.totals

    matched_hh = totals.get("matched_hh", 0.0)
    matched_shop = totals.get("matched_shop", 0.0)
    import_hh = totals.get("import_hh", 0.0)
    import_shop = totals.get("import_shop", 0.0)
    pv_gen = totals.get("pv_gen", 0.0)
    hh_demand = totals.get("hh_demand", 0.0)
    shop_demand = totals.get("shop_demand", 0.0)
    export = totals.get("export", 0.0)
    consumer_cost = totals.get("cons_cost", 0.0)
    consumer_cost_hh = totals.get("cons_cost_hh", 0.0)
    consumer_cost_shop = totals.get("cons_cost_shop", 0.0)
    consumer_base = totals.get("cons_baseline", 0.0)
    consumer_base_hh = totals.get("cons_baseline_hh", 0.0)
    consumer_base_shop = totals.get("cons_baseline_shop", 0.0)
    savings = consumer_base - consumer_cost
    savings_hh = totals.get("cons_savings_hh", consumer_base_hh - consumer_cost_hh)
    savings_shop = totals.get("cons_savings_shop", consumer_base_shop - consumer_cost_shop)

    pros_rev_total = totals.get("pros_rev", 0.0)
    pros_rev_matched = totals.get("pros_rev_matched", 0.0)
    pros_rev_export = totals.get("pros_rev_export", 0.0)
    pros_rev_no_share = totals.get("pros_rev_no_share", 0.0)

    coverage_total = _safe_ratio(matched_hh + matched_shop, hh_demand + shop_demand) * 100
    coverage_hh = _safe_ratio(matched_hh, matched_hh + import_hh) * 100
    coverage_shop = _safe_ratio(matched_shop, matched_shop + import_shop) * 100

    pv_util = _safe_ratio(matched_hh + matched_shop, pv_gen) * 100
    export_ratio = _safe_ratio(export, pv_gen) * 100

    autarky_total = (1.0 - _safe_ratio(import_hh + import_shop, hh_demand + shop_demand)) * 100
    autarky_hh = (1.0 - _safe_ratio(import_hh, matched_hh + import_hh)) * 100
    autarky_shop = (1.0 - _safe_ratio(import_shop, matched_shop + import_shop)) * 100

    savings_pct = _safe_ratio(savings, consumer_base) * 100
    prosumer_uplift = _safe_ratio(pros_rev_total, pros_rev_no_share) * 100

    rows = [
        ("PV generation", "kWh", pv_gen),
        ("Prosumer demand", "kWh", totals.get("pros_demand", 0.0)),
        ("HH demand", "kWh", hh_demand),
        ("Shop demand", "kWh", shop_demand),
        ("Matched to HH", "kWh", matched_hh),
        ("Matched to SHOP", "kWh", matched_shop),
        ("Exports", "kWh", export),
        ("Imports HH", "kWh", import_hh),
        ("Imports SHOP", "kWh", import_shop),
        ("Community demand", "kWh", hh_demand + shop_demand),
        ("Coverage — total", "%", coverage_total),
        ("Coverage — HH", "%", coverage_hh),
        ("Coverage — SHOP", "%", coverage_shop),
        ("PV utilization", "%", pv_util),
        ("Export ratio", "%", export_ratio),
        ("Autarky — total", "%", autarky_total),
        ("Autarky — HH", "%", autarky_hh),
        ("Autarky — SHOP", "%", autarky_shop),
        ("Prosumer uplift rate", "%", prosumer_uplift),
        ("Prosumer revenue", "€", pros_rev_total),
        ("Prosumer revenue from matched energy", "€", pros_rev_matched),
        ("Prosumer revenue from export", "€", pros_rev_export),
        ("Consumer baseline", "€", consumer_base),
        ("Consumer baseline HH", "€", consumer_base_hh),
        ("Consumer baseline SHOP", "€", consumer_base_shop),
        ("Consumer cost — total", "€", consumer_cost),
        ("Consumer savings", "€", savings),
        ("Consumer savings — HH", "€", savings_hh),
        ("Consumer savings — SHOP", "€", savings_shop),
        ("Consumer savings", "%", savings_pct),
        ("Platform gap revenue", "€", totals.get("platform_gap", 0.0)),
        ("Platform fees", "€", totals.get("platform_fees", 0.0)),
        ("Platform fixed cost", "€", totals.get("platform_fixed", 0.0)),
        ("Platform margin", "€", totals.get("platform_margin", 0.0)),
    ]

    df = pd.DataFrame(rows, columns=["KPI", "unit", "value"])
    df["description"] = df["KPI"].map(KPI_DESCRIPTIONS).fillna("")
    return df


def render_kpi_dashboard(S: AppState):
    summary = compute_kpi_summary(S)
    if summary.empty:
        st.warning("Run the deterministic scenario to view KPIs.")
        return

    st.subheader("Headline rates")
    rate_df = summary[summary["unit"] == "%"].set_index("KPI")
    highlight_names = [
        "Coverage — total",
        "PV utilization",
        "Autarky — total",
        "Consumer savings",
        "Prosumer uplift rate",
    ]
    highlight = rate_df.reindex(highlight_names).dropna(subset=["value"])
    if not highlight.empty:
        cols = st.columns(len(highlight))
        for col, (kpi, row) in zip(cols, highlight.iterrows()):
            with col:
                help_text = row.get("description", "")
                st.metric(kpi, f"{row['value']:.2f}%", help=help_text or None)

    st.subheader("Energy balances (kWh)")
    st.caption("All energy KPIs represent total community values.")
    energy_df = summary[summary["unit"] == "kWh"].set_index("KPI")[["value", "description"]].copy()
    if not energy_df.empty:
        energy_df["value"] = energy_df["value"].round(3)
        energy_df.rename(columns={"value": "Value", "description": "Definition"}, inplace=True)
        st.dataframe(energy_df, use_container_width=True)

    st.subheader("Rates (%)")
    if not rate_df.empty:
        kpi_list = rate_df.index.tolist()
        for start in range(0, len(kpi_list), 3):
            chunk = kpi_list[start:start + 3]
            cols = st.columns(len(chunk))
            for col, kpi in zip(cols, chunk):
                value = rate_df.at[kpi, "value"]
                desc = rate_df.at[kpi, "description"]
                with col:
                    st.metric(kpi, f"{value:.2f}%", help=desc or None)

    st.subheader("Economics (€)")
    st.caption("All economic values refer to totals for the entire community.")
    econ_df = summary[summary["unit"] == "€"].set_index("KPI")[["value", "description"]].copy()
    if not econ_df.empty:
        econ_df["value"] = econ_df["value"].round(2)
        econ_df.rename(columns={"value": "Value", "description": "Definition"}, inplace=True)
        st.dataframe(econ_df, use_container_width=True)
